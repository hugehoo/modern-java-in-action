# **`Chapter1` | 소개 및 개요**

### DBMS 구조

- DBMS 는 클라이언트/서버 모델을 기반으로 하며, 데이터베이스와 애플리케이션은 각각 서버, 클라이언트 역할을 한다.
    - 클라이언트의 요청은 `트랜스포트 서브시스템`을 통해 전달된다.
        - 요청은 쿼리 형태로 전달
        - 특정 쿼리 언어로 표현된다. (sql, nosql)
- **트랜스포트 서브시스템**은 DB 클러스터 노드 사이의 통신에도 사용된다.
- **트랜스포트 서브시스템**은 쿼리를 쿼리 프로세서에 전달하고, 쿼리 프로세서는 쿼리를 해석, 분석, 검증한다.
- 분석된 쿼리는 쿼리 옵티마이저에 전달된다.
    - 쿼리에서 논리적으로 불가능한 부분과 중복을 제거한 후 내부 데이터 통계와 데이터 위치 등을 기반으로 가장 효율적인 쿼리 실행 계획을 생성.
- 쿼리는 일반적인 실행 계획 형태로 표현된다.
    - 실행계획이란 쿼리가 요구하는 결과를 도출하는데 수행해야 하는 일련의 작업을 의미.
    - *동일한 쿼리라도 여러 다른 실행 계획이 존재할 수 있다.*
    - **옵티마이저**는 여러 실행 계획 중 가장 효율적인 것을 선택.


### 인메모리 DBMS vs 디스크 기반 DBMS

- 두 형시 모두 디스크를 사용하지만 인메모리 DBMS 는 대부분의 데이터를 RAM 에 저장
- 메모리는 디스크보다 훨씬 빠르게 데이터에 접근할 수 있다 (I/O 비용때문이 아닐까 생각)


    |  | 메모리 | 디스크 |
    | --- | --- | --- |
    | 인메모리 DBMS | 데이터 저장 | 디스크 복구 및 로그 저장 |
    | 디스크 DBMS | 캐싱, 임시 저장 용도 | 데이터 저장 |
- 메모리를 주 저장 매체로 사용하는 이유
    - 성능 / 낮은 데이터 접근 비용 / 세밀한 접근 단위 조절 / 프로그래밍 관점에서 메모리 제어 용이
- 인메모리의 가장 큰 단점
    - RAM 의 휘발성 및 높은 가격
        - 무정전 전원 장치, 배터리 장착 RAM 으로 데이터 영구 저장 가능하지만 추가적인 하드웨어 필요
        - 때문에 디스크는 메모리보다 유지관리 측면에서 더 간단하고 비용이 낮다.
- *what is NVM 스토리지(41pg)?*

### 인메모리 데이터베이스의 지속성

- 데이터 손실 방지 위해 데이터를 디스크에 백업함
- 모든 작업은 로그 파일에 작업 내용을 순차적으로 기록해야 완료됨
    - 익히 들은 `선행 기록 로그(write ahead log)`
    - 백업본은 디스크 기반 자료구조에 순서대로 저장 → 수정 내용은 비동기적으로 갱신되며, I/O 작업을 최소화 하기 위해 배치 단위로 백업한다.
    - 로그 레코드는 일반적으로 배치 단위로 백업한다. 배치 작업이 완료되면 백업본은 특정 시점의 데이터베이스의 스냅숏이기 때문에 이 시점 이전의 로그는 삭제해도 된다. 이러한 작업을 체크포인트를 남긴다고 표현한다. 클라이언트의 요청을 블로킹하지 않고 디스크에 저장된 백업본을 최신 로그 데이터와 동기화하면 복구 시간을 단축할 수 있다.

### 컬럼형 DBMS vs 로우형 DBMS

- 데이터를 디스크에 저장하는 방식에 따라 DB 를 분류
    - 컬럼 저장 방식은 테이블을 수직분할
    - 로우 저장 방식은 테이블을 수평분할
- 로우형 데이터 레이아웃
    - 데이터 레코드를 로우 형식으로 저장하며 모든 row 구성 필드는 동일하다.
        - 논리적으로 동일한 레코드에 속하는 값의 집합을 row 로 부른다.
- 컬럼형 데이터 레이아웃
    - 데이터를 수직분할 하여 저장한다.
    - 동일한 컬럼끼리 디스크에 연속해 저장
        - ex) 주식 정보 : 주식 시세만 따로 모아서 저장하는 것이 효율적
    - 데이터의 추세와 평균 등을 계산하는 집계 분석 작업에 적합
    - 컬럼형 DBMS 에서 **조인, 필터링, 다중 로우 집계** 등을 위해 튜플을 재구성하려면, 컬럼 사이의 관계를 정의하는 `메타데이터` 필요
    - 대용량 데이터의 복잡한 분석 쿼리 사용이 늘어나서 아파치 파케, 아파치 ORC, RCFile 같은 컬럼 기반 파일 포맷이 각광받고 있다.

### 차이점과 최적화 기법

- 컬럼형과 로우형 중 어떤 것을 사용할지 선택하려면 액세스 패턴을 파악해야 한다.
    - 로우형 : 레코드 단위로 접근하고, 일반 쿼리와 범위 스캔 요청이 많은 경우
    - 컬럼형 : 많은 로우를 스캔하고 일부 컬럼에 대한 집계 작업이 많은 경우
- 같은 컬럼의 여러 값을 한번에 읽으면 캐시 활용도와 처리 효율성을 높일 수 있다.
    - 최신 CPU 는 ***벡터 연산***을 통해 한 번의 CPU 명령어로 많은 데이터를 처리 가능
    - 자료형 별로 저장하면 압축률도 증가 → 다양한 압축 알고리즘 중 해당 자료형에 가장 효과적인 기법을 선택할 수도 있다.


### 와이드 컬럼 스토어

- 데이터를 다차원 맵으로 표현하고 여러 컬럼을 같은 패밀리 단위로 저장한다.
- 컬럼 패밀리의 데이터는 로우 형식으로 저장 → 키-단위 액세스 패턴에 적합

### 데이터 파일과 인덱스 파일

- ***Why 데이터를 단순히 여러 파일에 나눠 저장하지 않고 DB를 사용할까?***
    - 데이터베이스 시스템은 데이터를 파일에 저장하지만, 디렉터리와 파일 구조 기반 파일 시스템 대신 특수한 포맷을 사용한다.
- 일반 파일을 사용하지 않는 이유
    - 저장 효율성 : 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성
    - 접근 효율성 : 최소한의 단계로 원하는 레코드를 찾을 수 있다.
    - 갱신 효율성 : 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- 데이터베이스 시스템은 데이터 파일과 인덱스 파일을 분리한다.
    - 데이터 파일 → 데이터 레코드 저장
    - 인덱스 파일 → 레코드의 메타 데이터를 저장 → 데이터 파일에서 레코드의 위치 찾는데 활용
- 파일은 한 개 이상의 디스크 블록으로 이루어진 **페이지**로 구성된다. → *결국 파일은 페이지로 구성된다(?)*
    - 페이지는 레코드 또는 슬롯 페이지의 집합이다.

### 데이터 파일

- 데이터 파일은 `인덱스 구조형 테이블` / `힙 구조형 테이블` / `해시 구조형 테이블` 을 기반으로 한다.
- 힙 파일 (힙 구조형 테이블)
    - 레코드를 특정 순서를 따르지 않고 삽입 순서대로 저장
    - 따라서 새로운 페이지가 추가돼도 파일을 재구성하지 않아도 된다.(?)
    - 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스 필요
- 해시 파일 (해시 구조형 테이블)
    - 레코드를 각 키의 해시 값에 해당하는 버킷에 저장
    - 버킷 내 레코드는 삽입 순서대로 저장.(키 순서로 정렬하면 조회 속도를 향상 시킬 수 있다.)
- 인덱스 구조형 테이블
    - 인덱스에 실제 데이터 레코드를 저장
    - 데이터는 키 순서로 정렬되기 때문에 IOT(Index Organized Table) 의 범위 스캔은 실제 값을 순서대로 읽으면서 비교.
    - Index 에 데이터 레코드를 저장하면 디스크 탐색 횟수를 최소 1회로 줄일 수 있다.(?)
    - Index 에서 키를 찾은 후 실제 데이터 레코드 없이도 바로 데이터를 반환할 수 있다.

### 인덱스 파일

- **디스크에 저장된 레코드를 효율적으로 검색할 수 있는 자료구조**
- **기본 인덱스**는 기본 키(PK) 또는 기본 키 역할을 할 수 있는 여러 키의 조합을 의미
- 그 외는 모두 **보조 인덱스**에 해당
- **보조 인덱스**는 데이터 레코드를 직접 가리키거나 해당 레코드의 기본 키를 저장
    - 데이터 레코드 포인터는 힙 파일 또는 IOT 의 오프셋이다.

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3a1b7be8-f339-41be-ada3-0da4ec08f87e/faedd965-2033-4a2f-a9ce-81990ccf3857/Untitled.png)

- 기본 인덱스 파일은 하나의 레코드만 가리키는 반면, 보조 인덱스는 키별로 여러 레코드를 가리킬 수도 있다.

- 실제 데이터 레코드 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스를 **클러스터형 인덱스**라고 한다.
    - 클러스터형 인덱스의 데이터 레코드는 보통 같은 인덱스 파일 또는 클러스터형 파일에 정렬해 저장한다.
- 데이터가 다른 파일에 저장돼 있고 인덱스 키를 기준으로 정렬되지 않은 인덱스는 **비클러스터형 인덱스**라 한다.

### 기본 인덱스 통한 간접 참조

- 데이터 레코드를 직접(**파일 오프셋**) 참조 VS 기본 키 인덱스를 통해 접근
    - **직접 참조**
        - 디스크 탐색 오버헤드가 줄어든다.
        - 하지만 레코드를 갱신하거나 위치를 변경할 때마다 포인터를 수정해야 하는 오버헤드 존재
    - **인덱스 통한 참조**
        - 포인터 갱신 비용이 줄어들지만, 레코드 위치를 찾는 과정이 추가됨
- 읽기 작업이 많은 경우 인덱스 개수가 많아도 괜춘
- 쓰기 작업이 많은 경우 인덱스 개수가 많으면 포인터 갱신이 문제.
- 때문에 일부 시스템은(ex MySQL InnoDB) 기본 인덱스를 사용해 룩업(look up)을 두번 수행한다.

  (직접 참조 하지 않는다는 의미)

    - 1) 보조 인덱스에서 키를 찾고
    - 2) 기본 인덱스에서 해당 레코드를 참조
    - 3) 오프셋을 통해 직접 참조하지 않기 때문에 기본 인덱스 룩업 비용이 추가 발생함.

### 버퍼링과 불변성, 순서화

- 데이터베이스 자료구조에는 3가지 공통점 <`버퍼링` / `가변성` / `순서화`> 존재
- **버퍼링**
    - **데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것의 의미**
    - 모든 디스크 기반 자료구조에서는 버퍼를 어느정도 사용한다.
        - 디스크와 데이터를 주고받는 가장 작은 전송 단위는 블록이므로 블록을 채워서 쓰는 것이 바람직하기 때문.
    - 여기서 버퍼링이란 일부 스토리지 엔진에서 의도적으로 사용하는 버퍼링을 의미한다.(?)
- **가변성 (또는 불변성)**
    - 파일 일부를 읽고 갱신한 뒤 똑같은 자리에 다시 쓸지에 대하 여부
    - 불변 구조는 (당연히) 한 번 쓴 파일 내용은 고칠 수 없다.
        - 파일 끝에 내용을 추가하는 추가 전용 구조이다 (append-only)
- **순서화**
    - 디스크 페이지에 데이터 레코드를 키 순서로 저장하는 것을 의미
    - 인접한 키는 디스크의 연속된 세그먼트에 저장된다.
    - 순서화는 특정 데이터 레코드 검색뿐 아니라 효율적인 범위 스캔에 매우 중요한 속성이다.