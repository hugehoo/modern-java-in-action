자바의 진화
- 자바 8에서는 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다.
- e.g) 예를 들어, 우리가 하려는 작업이 최우선시되며, 그 작업을 구체적으로 어떻게 수행할지는 별개의 문제로 취급한다.
- 자바 8 이전에는 작업이 구체적으로 어떻게 수행될지 직접 코드를 구현해야 했다면, 자바 8 부터는 단순히 함수를 호출하는 것으로 원하는 작업을 수행할 수 있다.

함수를 값처럼 취급할 때의 장점
- 이급 시민을 일급 시민으로 만든 이유
- 자바의 다양한 값(객체, 인스턴스, 기본형, 참조형 등)
- 자바의 다양한 구조체(클래스, 메서드)는 값의 구조를 표현하는데 도움이 될 수 있다.
  - 하지만 프로그램을 실행하는 동안 이러한 구조체는 자유롭게 전달할 수 없다.
  - 이렇게 전달할 수 없는 구조체를 이급 시민이라 한다.
  - 즉 메서드와 클래스는 그 자체로 값이 될 수 없다. 
  - 이게 왜 중요한가?
  - 만약 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들수 있으면 프로그래밍에 유용하게 활용할 수 있다. 
  - Q. 일급 시민은 무엇인가?

메서드와 람다를 일급 시민으로(값으로 취급할 수 있도록)
- 메서드 참조 `::` ( 이 메서드를 값으로 사용하라는 의미) 
- isHidden() 이라는 함수를 값(인수)처럼 넘길 수 있게 됐다.
- isHidden() 메서드를 File 의 객체 참조하는 것이 아닌, 메서드 참조를 만들어 전달할 수 있게 됨 
``` java
// before Java 8
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file){
        return file.isHidden();
    }
});

// since Java 8
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

### 디폴트 메서드와 자바 모듈
- 인터페이스를 구현한 클래스가 여러가지 일 때, 인터페이스를 변경하는 것은 어려운 일이다.
- 하지만 디폴트 메서드가 등장하면서 인터페이스를 구현하는 클래스를 강제로 변경하지 않아도 된다.
- 예를 들어 자바8 이전에는 List<T> 가 stream 이나 parallelStream 메서드를 지원하지 않는다는 것이 문제였다. 그 때문에 아래의 코드는 컴파일 되지 않았다.
- 그럼 어떻게 기존 구현을 고치지 않고, 이미 공개된 인터페이스를 변경할 수 있을까?
- Default Method 의 등장이 이를 해결한다.
- 메서드 구현의 책임이 구체 클래스에 있지 않고, 인터페이스의 일부로 포함된다.
``` java
List<Apple> collect = inventory.parallelStream()
.filter((Apple a) -> a.getWeight() > 100)
.toList();
```

``` java
// Collection Interface
// parallelStream() 디폴트 메서드로 구현돼 있는걸 확인 가능
default Stream<E> parallelStream() {
    return StreamSupport.stream(spliterator(), true);
}
```

- 자바8 이전에 `sort()` 메서드는 직접 구현해야 했지만, 
- 자바8 이후 List 인터페이스에 sort() 디폴트 메서드가 추가되어 List 의 인스턴스는 sort 메서드를 직접 호출할 수 있다.


### 마치며
- 자바8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능 제공
- 기존 자바는 멀티코어 프로세서를 온전히 활용하기 어렵다 -> 스트림의 등장으로 멀티코어를 비교적 쉽게 다룰 수 있다.
- 함수는 일급값이다, 메서드를 어떻게 함수형값으로 넘기는지, 익명함수를 어떻게 구현하는지 기억하자. 